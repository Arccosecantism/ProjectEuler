#Problem: How many L (L is intger <= 1,500,000 are there such that L can be represented as the sum of the three
#           terms of a pythagorean triple in exactly one way?

from time import time


def primeFactorSieve(x):
    #Produces a list of numbers under x, also tells if they are prime.
    ar = []
    for i in range(-1,x):
        ar.append([])
    
    ub = int(x/2)+1
    for i in range(2,ub):
        if ar[i] == []:
            for k in range(i,x,i):
                ar[k].append(i)
    for i in range(2,x+1):
        if ar[i] == []:
            ar[i] = [i]
    return ar

def generateSomeCoprimeNumbers(x, pfs, under):
    #generates a list of numbers x is relatively prime with and such that, for any element j in the list,
    #x and j aren't both odd (this last part helps in generating pythag triples)
    numList = [1]*under
    if x&1:
        for i in range(0,len(numList)):
            if not(i&1):
                numList[i] = 0
    facs = pfs[x]
    for i in facs:
        for k in range(0,len(numList)):
            if not((k+1)%i):
                numList[k] = 0
    for i in range(0, len(numList)):
        if i+1 <= x:
            numList[i] = 0
    goodList = []
    for i in range(0,len(numList)):
        if numList[i] == 1:
            goodList.append(i+1)
    return goodList
    



def main():
    #The Strategy: some research shows that for any two integers m and n where m and n are coprime and not both are odd,
    #then (a = m^2-n^2, b = 2mn, c = m^2+n^2) is a "primitive" pythagorean triple (not just a multiple of another one,
    #as (3,4,5) implies (6,8,10) is also a pythag triple). In fact, provided enough different m's and n's are used, 
    #all pythagorean triples will be generated uniquely. So, since if m or n is >= 870 and since we only care about
    #positive integers, the sum of the triples must be greater than 2*870^2, wich is > 1,500,000, so If we use only
    #integers under 570, I must hit every pythagorean triple summing up to less than or equa to 1,500,000
    #To generate the sum of a non-primitive triple, we just take a primitive triple's sum and consider all of its 
    #multiples under 1,500,000.

    #So, I pick each m from 1-870 and generate a list of coprime numbers such that n and m aren't both odd.
    #Then, I find the sum of each triple in the family of triples containing multiples of primitive triples
    #generated by each combination of m's and n's. then, in a 150,000,001 list full of 0s initially, I add 1 to the 
    #kth spot, where k is my current sum I am considering.
    #Then, I simply count up the number of spots that = 1
    # 
    #Executes in  

    t0 = time()
    sieve = primeFactorSieve(1000000)
    ptripSums = []
    for i in range(1,870):
        cnums = generateSomeCoprimeNumbers(i,sieve,870)
        for k in cnums:
            ptripSums.append(2*k*k+2*k*i)

    sumList = [0]*1500001
    for i in ptripSums:
        ssum = i
        bsum = ssum
        while bsum <= 1500000:
            sumList[bsum] += 1
            bsum += ssum
    fsum = 0
    for i in range(0,len(sumList)):
        if sumList[i] == 1:
            fsum += 1
            #print(sumList[i],i)
    print("Time Elapsed:", time()-t0)
    print(fsum)

main()